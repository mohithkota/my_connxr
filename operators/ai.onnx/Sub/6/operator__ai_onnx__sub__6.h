//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX__SUB__6_H
# define OPERATOR_OPERATOR__AI_ONNX__SUB__6_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx operator 'Sub' version 6
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Performs element-wise binary subtraction (with limited broadcast support).
 * 
 * If necessary the right-hand-side argument will be broadcasted to match the
 * shape of left-hand-side argument. When broadcasting is specified, the second
 * tensor can either be of element size 1 (including a scalar tensor and any
 * tensor with rank equal to or smaller than the first tensor), or having its
 * shape as a contiguous subset of the first tensor's shape. The starting of the
 * mutually equal shape is specified by the argument "axis", and if it is not set,
 * suffix matching is assumed. 1-dim expansion doesn't work yet.
 * 
 * For example, the following tensor shapes are supported (with broadcast=1):
 * 
 *   shape(A) = (2, 3, 4, 5), shape(B) = (,), i.e. B is a scalar tensor
 *   shape(A) = (2, 3, 4, 5), shape(B) = (1, 1), i.e. B is an 1-element tensor
 *   shape(A) = (2, 3, 4, 5), shape(B) = (5,)
 *   shape(A) = (2, 3, 4, 5), shape(B) = (4, 5)
 *   shape(A) = (2, 3, 4, 5), shape(B) = (3, 4), with axis=1
 *   shape(A) = (2, 3, 4, 5), shape(B) = (2), with axis=0
 * 
 * Attribute `broadcast=1` needs to be passed to enable broadcasting.
 * 
 * Constraint T:
 *   Constrain input and output types to high-precision numeric tensors.
 *   Allowed Types: tensor_double, tensor_float, tensor_float16, tensor_int32,
 *                  tensor_int64, tensor_uint32, tensor_uint64
 * Input T A:
 *   First operand, should share the type with the second operand.
 *   Allowed Types: tensor_double, tensor_float, tensor_float16, tensor_int32,
 *                  tensor_int64, tensor_uint32, tensor_uint64
 * 
 * Input T B:
 *   Second operand. With broadcasting can be of smaller size than A. If
 *   broadcasting is disabled it should be of the same size.
 *   Allowed Types: tensor_double, tensor_float, tensor_float16, tensor_int32,
 *                  tensor_int64, tensor_uint32, tensor_uint64
 * Output T C:
 *   Result, has same dimensions and type as A
 *   Allowed Types: tensor_double, tensor_float, tensor_float16, tensor_int32,
 *                  tensor_int64, tensor_uint32, tensor_uint64
 * Attribute INT axis (optional):
 *   If set, defines the broadcast dimensions. See doc for details.
 * 
 * Attribute INT broadcast (optional):
 *   Pass 1 to enable broadcasting
 *
 * @since version 6
 *
 * @see github/workspace/onnx/defs/math/old.cc:2637
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators.md#Sub
 */

operator_status
prepare_operator__ai_onnx__sub__6(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx__sub__6;

typedef struct {
// no attributes
} context_operator__ai_onnx__sub__6;

operator_executer
resolve_operator__ai_onnx__sub__6(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_double(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_float16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_uint32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__sub__6__T_tensor_uint64(
    node_context *ctx
);

# endif