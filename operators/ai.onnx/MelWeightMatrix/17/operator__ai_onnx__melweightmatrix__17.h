//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX__MELWEIGHTMATRIX__17_H
# define OPERATOR_OPERATOR__AI_ONNX__MELWEIGHTMATRIX__17_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx operator 'MelWeightMatrix' version 17
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Generate a MelWeightMatrix that can be used to re-weight a Tensor containing a linearly sampled frequency spectra (from DFT or STFT) into num_mel_bins frequency information based on the [lower_edge_hertz, upper_edge_hertz] range on the mel scale.
 * This function defines the mel scale in terms of a frequency in hertz according to the following formula:
 * 
 *     mel(f) = 2595 * log10(1 + f/700)
 * 
 * In the returned matrix, all the triangles (filterbanks) have a peak value of 1.0.
 * 
 * The returned MelWeightMatrix can be used to right-multiply a spectrogram S of shape [frames, num_spectrogram_bins] of linear scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram" M of shape [frames, num_mel_bins].
 * 
 * Constraint T1:
 *   Constrain to integer tensors.
 *   Allowed Types: tensor_int32, tensor_int64
 * 
 * Constraint T2:
 *   Constrain to float tensors
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Constraint T3:
 *   Constrain to any numerical types.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16, tensor_int16, tensor_int32, tensor_int64,
 *                  tensor_int8, tensor_uint16, tensor_uint32, tensor_uint64,
 *                  tensor_uint8
 * Input T1 num_mel_bins:
 *   The number of bands in the mel spectrum.
 *   Allowed Types: tensor_int32, tensor_int64
 * 
 * Input T1 dft_length:
 *   The size of the original DFT. The size of the original DFT is used to
 *   infer the size of the onesided DFT, which is understood to be
 *   floor(dft_length/2) + 1, i.e. the spectrogram only contains the
 *   nonredundant DFT bins.
 *   Allowed Types: tensor_int32, tensor_int64
 * 
 * Input T1 sample_rate:
 *   Samples per second of the input signal used to create the spectrogram.
 *   Used to figure out the frequencies corresponding to each spectrogram bin,
 *   which dictates how they are mapped into the mel scale.
 *   Allowed Types: tensor_int32, tensor_int64
 * 
 * Input T2 lower_edge_hertz:
 *   Lower bound on the frequencies to be included in the mel spectrum. This
 *   corresponds to the lower edge of the lowest triangular band.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Input T2 upper_edge_hertz:
 *   The desired top edge of the highest frequency band.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * Output T3 output:
 *   The Mel Weight Matrix. The output has the shape: [floor(dft_length/2) +
 *   1][num_mel_bins].
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16, tensor_int16, tensor_int32, tensor_int64,
 *                  tensor_int8, tensor_uint16, tensor_uint32, tensor_uint64,
 *                  tensor_uint8
 * Attribute INT output_datatype (optional):
 *   The data type of the output tensor. Strictly must be one of the values
 *   from DataType enum in TensorProto whose values correspond to T3. The
 *   default value is 1 = FLOAT.
 *
 * @since version 17
 *
 * @see github/workspace/onnx/defs/math/defs.cc:3277
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators.md#MelWeightMatrix
 */

operator_status
prepare_operator__ai_onnx__melweightmatrix__17(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx__melweightmatrix__17;

typedef struct {
// no attributes
} context_operator__ai_onnx__melweightmatrix__17;

operator_executer
resolve_operator__ai_onnx__melweightmatrix__17(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int32__T2_tensor_bfloat16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int32__T2_tensor_double(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int32__T2_tensor_float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int32__T2_tensor_float16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int64__T2_tensor_bfloat16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int64__T2_tensor_double(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int64__T2_tensor_float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__melweightmatrix__17__T1_tensor_int64__T2_tensor_float16(
    node_context *ctx
);

# endif