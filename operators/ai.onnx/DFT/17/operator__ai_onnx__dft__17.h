//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX__DFT__17_H
# define OPERATOR_OPERATOR__AI_ONNX__DFT__17_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx operator 'DFT' version 17
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Computes the discrete Fourier transform of input.
 * 
 * Constraint T1:
 *   Constrain input and output types to float tensors.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Constraint T2:
 *   Constrain scalar length types to int64_t.
 *   Allowed Types: tensor_int32, tensor_int64
 * Input T1 input:
 *   For real input, the following shape is expected:
 *   [batch_idx][signal_dim1][signal_dim2]...[signal_dimN][1]. For complex
 *   input, the following shape is expected:
 *   [batch_idx][signal_dim1][signal_dim2]...[signal_dimN][2]. The first
 *   dimension is the batch dimension. The following N dimensions correspond to
 *   the signal's dimensions. The final dimension represents the real and
 *   imaginary parts of the value in that order.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Input T2 dft_length:
 *   The length of the signal as a scalar. If greater than the axis dimension,
 *   the signal will be zero-padded up to dft_length. If less than the axis
 *   dimension, only the first dft_length values will be used as the signal.
 *   It's an optional value.
 *   Allowed Types: tensor_int32, tensor_int64
 * Output T1 output:
 *   The Fourier Transform of the input vector. If onesided is 0, the
 *   following shape is expected:
 *   [batch_idx][signal_dim1][signal_dim2]...[signal_dimN][2]. If axis=1 and
 *   onesided is 1, the following shape is expected:
 *   [batch_idx][floor(signal_dim1/2)+1][signal_dim2]...[signal_dimN][2]. If
 *   axis=2 and onesided is 1, the following shape is expected:
 *   [batch_idx][signal_dim1][floor(signal_dim2/2)+1]...[signal_dimN][2]. If
 *   axis=N and onesided is 1, the following shape is expected:
 *   [batch_idx][signal_dim1][signal_dim2]...[floor(signal_dimN/2)+1][2]. The
 *   signal_dim at the specified axis is equal to the dft_length.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * Attribute INT axis (optional):
 *   The axis on which to perform the DFT. By default this value is set to 1,
 *   which corresponds to the first dimension after the batch index. Negative
 *   value means counting dimensions from the back. Accepted range is $[-r, -2]
 *   \cup [0, r-2]$ where `r = rank(input)`. The last dimension is for
 *   representing complex numbers and thus is an invalid axis.
 * 
 * Attribute INT inverse (optional):
 *   Whether to perform the inverse discrete fourier transform. By default
 *   this value is set to 0, which corresponds to false.
 * 
 * Attribute INT onesided (optional):
 *   If onesided is 1, only values for w in [0, 1, 2, ..., floor(n_fft/2) + 1]
 *   are returned because the real-to-complex Fourier transform satisfies the
 *   conjugate symmetry, i.e., X[m, w] = X[m, n_fft-w]*. Note if the input or
 *   window tensors are complex, then onesided output is not possible. Enabling
 *   onesided with real inputs performs a Real-valued fast Fourier transform
 *   (RFFT). When invoked with real or complex valued input, the default value
 *   is 0. Values can be 0 or 1.
 *
 * @since version 17
 *
 * @see github/workspace/onnx/defs/math/old.cc:3948
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators.md#DFT
 */

operator_status
prepare_operator__ai_onnx__dft__17(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx__dft__17;

typedef struct {
// no attributes
} context_operator__ai_onnx__dft__17;

operator_executer
resolve_operator__ai_onnx__dft__17(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_bfloat16__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_bfloat16__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_double__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_double__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_float__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_float__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_float16__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__17__T1_tensor_float16__T2_tensor_int64(
    node_context *ctx
);

# endif