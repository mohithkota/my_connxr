//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX_ML__LABELENCODER__2_H
# define OPERATOR_OPERATOR__AI_ONNX_ML__LABELENCODER__2_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx.ml operator 'LabelEncoder' version 2
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Maps each element in the input tensor to another value.<br>
 *     The mapping is determined by the two parallel attributes, 'keys_*' and
 *     'values_*' attribute. The i-th value in the specified 'keys_*' attribute
 *     would be mapped to the i-th value in the specified 'values_*' attribute. It
 *     implies that input's element type and the element type of the specified
 *     'keys_*' should be identical while the output type is identical to the
 *     specified 'values_*' attribute. If an input element can not be found in the
 *     specified 'keys_*' attribute, the 'default_*' that matches the specified
 *     'values_*' attribute may be used as its output value.<br>
 *     Let's consider an example which maps a string tensor to an integer tensor.
 *     Assume and 'keys_strings' is ["Amy", "Sally"], 'values_int64s' is [5, 6],
 *     and 'default_int64' is '-1'.  The input ["Dori", "Amy", "Amy", "Sally",
 *     "Sally"] would be mapped to [-1, 5, 5, 6, 6].<br>
 *     Since this operator is an one-to-one mapping, its input and output shapes
 *     are the same. Notice that only one of 'keys_*'/'values_*' can be set.<br>
 *     For key look-up, bit-wise comparison is used so even a float NaN can be
 *     mapped to a value in 'values_*' attribute.<br>
 * 
 * Constraint T1:
 *   The input type is a tensor of any shape.
 *   Allowed Types: tensor_float, tensor_int64, tensor_string
 * 
 * Constraint T2:
 *   Output type is determined by the specified 'values_*' attribute.
 *   Allowed Types: tensor_float, tensor_int64, tensor_string
 * Input T1 X:
 *   Input data. It can be either tensor or scalar.
 *   Allowed Types: tensor_float, tensor_int64, tensor_string
 * Output T2 Y:
 *   Output data.
 *   Allowed Types: tensor_float, tensor_int64, tensor_string
 * Attribute FLOAT default_float (optional):
 *   A float.
 * 
 * Attribute INT default_int64 (optional):
 *   An integer.
 * 
 * Attribute STRING default_string (optional):
 *   A string.
 * 
 * Attribute FLOATS keys_floats (optional):
 *   A list of floats.
 * 
 * Attribute INTS keys_int64s (optional):
 *   A list of ints.
 * 
 * Attribute STRINGS keys_strings (optional):
 *   A list of strings. One and only one of 'keys_*'s should be set.
 * 
 * Attribute FLOATS values_floats (optional):
 *   A list of floats.
 * 
 * Attribute INTS values_int64s (optional):
 *   A list of ints.
 * 
 * Attribute STRINGS values_strings (optional):
 *   A list of strings. One and only one of 'value_*'s should be set.
 *
 * @since version 2
 *
 * @see github/workspace/onnx/defs/traditionalml/old.cc:561
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators-ml.md#LabelEncoder
 */

operator_status
prepare_operator__ai_onnx_ml__labelencoder__2(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx_ml__labelencoder__2;

typedef struct {
// no attributes
} context_operator__ai_onnx_ml__labelencoder__2;

operator_executer
resolve_operator__ai_onnx_ml__labelencoder__2(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__labelencoder__2(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__labelencoder__2__T1_tensor_float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__labelencoder__2__T1_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__labelencoder__2__T1_tensor_string(
    node_context *ctx
);

# endif