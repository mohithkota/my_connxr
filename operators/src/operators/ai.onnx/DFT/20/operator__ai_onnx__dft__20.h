//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX__DFT__20_H
# define OPERATOR_OPERATOR__AI_ONNX__DFT__20_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx operator 'DFT' version 20
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Computes the discrete Fourier Transform (DFT) of the input.
 * 
 * Assuming the input has shape `[M, N]`, where `N` is the dimension over which the
 * DFT is computed and `M` denotes the conceptual "all other dimensions,"
 * the DFT `y[m, k]` of shape `[M, N]` is defined as
 * 
 * $$y[m, k] = \sum_{n=0}^{N-1} e^{-2 \pi j \frac{k n}{N} } x[m, n] ,$$
 * 
 * and the inverse transform is defined as
 * 
 * $$x[m, n] = \frac{1}{N} \sum_{k=0}^{N-1} e^{2 \pi j \frac{k n}{N} } y[m, k] ,$$
 * 
 * where $j$ is the imaginary unit.
 * 
 * The actual shape of the output is specified in the "output" section.
 * 
 * Reference: https://docs.scipy.org/doc/scipy/tutorial/fft.html
 * 
 * Constraint T1:
 *   Constrain input and output types to float tensors.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Constraint T2:
 *   Constrain scalar length types to integers.
 *   Allowed Types: tensor_int32, tensor_int64
 * Input T1 input:
 *   For real input, the following shape is expected:
 *   `[signal_dim0][signal_dim1][signal_dim2]...[signal_dimN][1]`. For complex
 *   input, the following shape is expected:
 *   `[signal_dim0][signal_dim1][signal_dim2]...[signal_dimN][2]`. The final
 *   dimension represents the real and imaginary parts of the value in that
 *   order.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Input T2 dft_length:
 *   The length of the signal as a scalar. If greater than the axis dimension,
 *   the signal will be zero-padded up to `dft_length`. If less than the axis
 *   dimension, only the first `dft_length` values will be used as the signal.
 *   Allowed Types: tensor_int32, tensor_int64
 * 
 * Input tensor(int64) axis:
 *   The axis as a scalar on which to perform the DFT. Default is `-2` (last
 *   signal axis). Negative value means counting dimensions from the back.
 *   Accepted range is $[-r, -2] \cup [0, r-2]$ where `r = rank(input)`. The
 *   last dimension is for representing complex numbers and thus is an invalid
 *   axis.
 *   Allowed Types: tensor_int64
 * Output T1 output:
 *   The Fourier Transform of the input vector. If `onesided` is `0`, the
 *   following shape is expected:
 *   `[signal_dim0][signal_dim1][signal_dim2]...[signal_dimN][2]`. If `axis=0`
 *   and `onesided` is `1`, the following shape is expected:
 *   `[floor(signal_dim0/2)+1][signal_dim1][signal_dim2]...[signal_dimN][2]`.
 *   If `axis=1` and `onesided` is `1`, the following shape is expected:
 *   `[signal_dim0][floor(signal_dim1/2)+1][signal_dim2]...[signal_dimN][2]`.
 *   If `axis=N` and `onesided` is `1`, the following shape is expected:
 *   `[signal_dim0][signal_dim1][signal_dim2]...[floor(signal_dimN/2)+1][2]`.
 *   The `signal_dim` at the specified `axis` is equal to the `dft_length`.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * Attribute INT inverse (optional):
 *   Whether to perform the inverse discrete Fourier Transform. Default is 0,
 *   which corresponds to `false`.
 * 
 * Attribute INT onesided (optional):
 *   If `onesided` is `1` and input is real, only values for `k` in `[0, 1, 2,
 *   ..., floor(n_fft/2) + 1]` are returned because the real-to-complex Fourier
 *   transform satisfies the conjugate symmetry, i.e., `X[m, k] = X[m,
 *   n_fft-k]*`, where `m` denotes "all other dimensions" DFT was not applied
 *   on. If the input tensor is complex, onesided output is not possible. Value
 *   can be `0` or `1`. Default is `0`.
 *
 * @since version 20
 *
 * @see github/workspace/onnx/defs/math/defs.cc:2895
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators.md#DFT
 */

operator_status
prepare_operator__ai_onnx__dft__20(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx__dft__20;

typedef struct {
// no attributes
} context_operator__ai_onnx__dft__20;

operator_executer
resolve_operator__ai_onnx__dft__20(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_bfloat16__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_bfloat16__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_double__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_double__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_float__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_float__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_float16__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__dft__20__T1_tensor_float16__T2_tensor_int64(
    node_context *ctx
);

# endif