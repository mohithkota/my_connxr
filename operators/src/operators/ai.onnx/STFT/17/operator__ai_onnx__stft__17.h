//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX__STFT__17_H
# define OPERATOR_OPERATOR__AI_ONNX__STFT__17_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx operator 'STFT' version 17
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Computes the Short-time Fourier Transform of the signal.
 * 
 * Constraint T1:
 *   Constrain signal and output to float tensors.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Constraint T2:
 *   Constrain scalar length types to int64_t.
 *   Allowed Types: tensor_int32, tensor_int64
 * Input T1 signal:
 *   Input tensor representing a real or complex valued signal. For real
 *   input, the following shape is expected: [batch_size][signal_length][1].
 *   For complex input, the following shape is expected:
 *   [batch_size][signal_length][2], where [batch_size][signal_length][0]
 *   represents the real component and [batch_size][signal_length][1]
 *   represents the imaginary component of the signal.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Input T2 frame_step:
 *   The number of samples to step between successive DFTs.
 *   Allowed Types: tensor_int32, tensor_int64
 * 
 * Input T1 window:
 *   A tensor representing the window that will be slid over the signal.The
 *   window must have rank 1 with shape: [window_shape]. It's an optional
 *   value.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * 
 * Input T2 frame_length:
 *   A scalar representing the size of the DFT. It's an optional value.
 *   Allowed Types: tensor_int32, tensor_int64
 * Output T1 output:
 *   The Short-time Fourier Transform of the signals.If onesided is 1, the
 *   output has the shape: [batch_size][frames][dft_unique_bins][2], where
 *   dft_unique_bins is frame_length // 2 + 1 (the unique components of the
 *   DFT) If onesided is 0, the output has the shape:
 *   [batch_size][frames][frame_length][2], where frame_length is the length of
 *   the DFT.
 *   Allowed Types: tensor_bfloat16, tensor_double, tensor_float,
 *                  tensor_float16
 * Attribute INT onesided (optional):
 *   If onesided is 1, only values for w in [0, 1, 2, ..., floor(n_fft/2) + 1]
 *   are returned because the real-to-complex Fourier transform satisfies the
 *   conjugate symmetry, i.e., X[m, w] = X[m,w]=X[m,n_fft-w]*. Note if the
 *   input or window tensors are complex, then onesided output is not possible.
 *   Enabling onesided with real inputs performs a Real-valued fast Fourier
 *   transform (RFFT).When invoked with real or complex valued input, the
 *   default value is 1. Values can be 0 or 1.
 *
 * @since version 17
 *
 * @see github/workspace/onnx/defs/math/defs.cc:3387
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators.md#STFT
 */

operator_status
prepare_operator__ai_onnx__stft__17(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx__stft__17;

typedef struct {
// no attributes
} context_operator__ai_onnx__stft__17;

operator_executer
resolve_operator__ai_onnx__stft__17(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_bfloat16__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_bfloat16__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_double__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_double__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_float__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_float__T2_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_float16__T2_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__stft__17__T1_tensor_float16__T2_tensor_int64(
    node_context *ctx
);

# endif