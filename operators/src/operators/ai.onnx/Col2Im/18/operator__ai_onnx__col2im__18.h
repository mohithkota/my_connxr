//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX__COL2IM__18_H
# define OPERATOR_OPERATOR__AI_ONNX__COL2IM__18_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx operator 'Col2Im' version 18
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * The operator rearranges column blocks back into a multidimensional image
 * 
 * Col2Im behaves similarly to PyTorch's fold https://pytorch.org/docs/stable/generated/torch.nn.Fold.html,
 * but it only supports *batched* multi-dimensional image tensors.
 * Another implementation in Python with N-dimension support can be found at https://github.com/f-dangel/unfoldNd/.
 * 
 * NOTE:
 *   Although specifying image_shape looks redundant because it could be calculated from
 *   convolution formulas, it is required as input for more advanced scenarios as explained
 *   at PyTorch's implementation (https://github.com/pytorch/pytorch/blob/master/aten/src/ATen/native/Col2Im.cpp#L10)
 * 
 * Constraint T:
 *   Constrain input and output types to all numeric tensor types.
 *   Allowed Types: tensor_bfloat16, tensor_bool, tensor_complex128,
 *                  tensor_complex64, tensor_double, tensor_float,
 *                  tensor_float16, tensor_int16, tensor_int32, tensor_int64,
 *                  tensor_int8, tensor_string, tensor_uint16, tensor_uint32,
 *                  tensor_uint64, tensor_uint8
 * Input T input:
 *   Input data tensor to be rearranged from column blocks back into an image.
 *   This is a 3-dimensional tensor containing [N, C *
 *   n-ary-product(block_shape), L], where N is batch dimension, C is image
 *   channel dimension and L is number of blocks.The blocks are enumerated in
 *   increasing lexicographic-order of their indices.For example, with an
 *   image-size 10*20 and block-size 9*18, there would be 2*3 blocks,
 *   enumerated in the order block(0, 0), block(0, 1), block(0, 2), block(1,
 *   0), block(1, 1), block(1, 2).
 *   Allowed Types: tensor_bfloat16, tensor_bool, tensor_complex128,
 *                  tensor_complex64, tensor_double, tensor_float,
 *                  tensor_float16, tensor_int16, tensor_int32, tensor_int64,
 *                  tensor_int8, tensor_string, tensor_uint16, tensor_uint32,
 *                  tensor_uint64, tensor_uint8
 * 
 * Input tensor(int64) image_shape:
 *   The shape of the spatial dimensions of the image after rearranging the
 *   column blocks.This is a 1-dimensional tensor with size of at least 2,
 *   containing the value [H_img, W_img] for a 2-D image or [dim_i1, dim_i2,
 *   ..., dim_iN] for a N-D image.
 *   Allowed Types: tensor_int64
 * 
 * Input tensor(int64) block_shape:
 *   The shape of the block to apply on the input.This is a 1-dimensional
 *   tensor of size of at least 2, containing the value [H_block, W_block] for
 *   a 2-D image or [dim_b1, dim_b2, ..., dim_bN] for a N-D block.This is the
 *   block-shape before dilation is applied to it.
 *   Allowed Types: tensor_int64
 * Output T output:
 *   Output tensor produced by rearranging blocks into an image.
 *   Allowed Types: tensor_bfloat16, tensor_bool, tensor_complex128,
 *                  tensor_complex64, tensor_double, tensor_float,
 *                  tensor_float16, tensor_int16, tensor_int32, tensor_int64,
 *                  tensor_int8, tensor_string, tensor_uint16, tensor_uint32,
 *                  tensor_uint64, tensor_uint8
 * Attribute INTS dilations (optional):
 *   1-dimensional tensor with dilation value along each spatial axis of the
 *   image. If not present, the dilation defaults to 1 along each spatial axis
 *   of the image.
 * 
 * Attribute INTS pads (optional):
 *   1-dimensional tensor with padding value for the beginning and ending
 *   along each spatial axis, it can take any value greater than or equal to 0.
 *   The value represent the number of pixels added to the beginning and end
 *   part of the corresponding axis. `pads` format should be as follow
 *   [x1_begin, x2_begin...x1_end, x2_end,...], where xi_begin is the number of
 *   pixels added at the beginning of axis `i` and xi_end is the number of
 *   pixels added at the end of axis `i`. If not present, the padding defaults
 *   to 0 along start and end of each spatial axis.
 * 
 * Attribute INTS strides (optional):
 *   1-dimensional tensor with stride value along each spatial axis. If not
 *   present, the stride defaults to 1 along each spatial axis.
 *
 * @since version 18
 *
 * @see github/workspace/onnx/defs/nn/defs.cc:2373
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators.md#Col2Im
 */

operator_status
prepare_operator__ai_onnx__col2im__18(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx__col2im__18;

typedef struct {
// no attributes
} context_operator__ai_onnx__col2im__18;

operator_executer
resolve_operator__ai_onnx__col2im__18(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_bfloat16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_bool(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_complex128(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_complex64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_double(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_float16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_int16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_int32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_int64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_int8(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_string(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_uint16(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_uint32(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_uint64(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx__col2im__18__T_tensor_uint8(
    node_context *ctx
);

# endif