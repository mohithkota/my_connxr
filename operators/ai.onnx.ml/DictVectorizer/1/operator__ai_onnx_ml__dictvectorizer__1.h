//this file was generated by ../../../../../../../../connx/connx_ajit/scripts/onnx_generator/OperatorHeader.py
# ifndef OPERATOR_OPERATOR__AI_ONNX_ML__DICTVECTORIZER__1_H
# define OPERATOR_OPERATOR__AI_ONNX_ML__DICTVECTORIZER__1_H

# include "operators/operator.h"
# include "operators/operator_stub.h"
# include "operators/operator_info.h"

/**
 * ai.onnx.ml operator 'DictVectorizer' version 1
 *
 * @param[in]  ctx  Operator context
 * @return          Status code
 *
 * Uses an index mapping to convert a dictionary to an array.<br>
 *     Given a dictionary, each key is looked up in the vocabulary attribute corresponding to
 *     the key type. The index into the vocabulary array at which the key is found is then
 *     used to index the output 1-D tensor 'Y' and insert into it the value found in the dictionary 'X'.<br>
 *     The key type of the input map must correspond to the element type of the defined vocabulary attribute.
 *     Therefore, the output array will be equal in length to the index mapping vector parameter.
 *     All keys in the input dictionary must be present in the index mapping vector.
 *     For each item in the input dictionary, insert its value in the output array.
 *     Any keys not present in the input dictionary, will be zero in the output array.<br>
 *     For example: if the ``string_vocabulary`` parameter is set to ``["a", "c", "b", "z"]``,
 *     then an input of ``{"a": 4, "c": 8}`` will produce an output of ``[4, 8, 0, 0]``.
 * 
 * Constraint T1:
 *   The input must be a map from strings or integers to either strings or a
 *   numeric type. The key and value types cannot be the same.
 *   Allowed Types: map_int64__double, map_int64__float, map_int64__string,
 *                  map_string__double, map_string__float, map_string__int64
 * 
 * Constraint T2:
 *   The output will be a tensor of the value type of the input map. It's
 *   shape will be [1,C], where C is the length of the input dictionary.
 *   Allowed Types: tensor_double, tensor_float, tensor_int64, tensor_string
 * Input T1 X:
 *   A dictionary.
 *   Allowed Types: map_int64__tensor_double, map_int64__tensor_float,
 *                  map_int64__tensor_string, map_string__tensor_double,
 *                  map_string__tensor_float, map_string__tensor_int64
 * Output T2 Y:
 *   A 1-D tensor holding values from the input dictionary.
 *   Allowed Types: tensor_double, tensor_float, tensor_int64, tensor_string
 * Attribute INTS int64_vocabulary (optional):
 *   An integer vocabulary array.<br>One and only one of the vocabularies must
 *   be defined.
 * 
 * Attribute STRINGS string_vocabulary (optional):
 *   A string vocabulary array.<br>One and only one of the vocabularies must
 *   be defined.
 *
 * @since version 1
 *
 * @see github/workspace/onnx/defs/traditionalml/defs.cc:224
 * @see https://github.com/onnx/onnx/blob/master/docs/Operators-ml.md#DictVectorizer
 */

operator_status
prepare_operator__ai_onnx_ml__dictvectorizer__1(
    node_context *ctx
);

extern operator_info info_operator__ai_onnx_ml__dictvectorizer__1;

typedef struct {
// no attributes
} context_operator__ai_onnx_ml__dictvectorizer__1;

operator_executer
resolve_operator__ai_onnx_ml__dictvectorizer__1(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1__T1_map_int64__double(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1__T1_map_int64__float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1__T1_map_int64__string(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1__T1_map_string__double(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1__T1_map_string__float(
    node_context *ctx
);

operator_status
execute_operator__ai_onnx_ml__dictvectorizer__1__T1_map_string__int64(
    node_context *ctx
);

# endif